From 84e1775961de1c9d2ab32159fc03f758591f5238 Mon Sep 17 00:00:00 2001
From: Steffan Karger <steffan.karger@fox-it.com>
Date: Mon, 19 Jun 2017 11:28:38 +0200
Subject: [PATCH] Fix remote-triggerable memory leaks (CVE-2017-7521)

Several of our OpenSSL-specific certificate-parsing code paths did not
always clear all allocated memory.  Since a client can cause a few bytes
of memory to be leaked for each connection attempt, a client can cause a
server to run out of memory and thereby kill the server.  That makes this
a (quite inefficient) DoS attack.

When using the --x509-alt-username option on openssl builds with an
extension (argument prefixed with "ext:", e.g. "ext:subjectAltName"), the
code would not free all allocated memory.  Fix this by using the proper
free function.

If ASN1_STRING_to_UTF8() returns 0, it didn't fail and *did* allocate
memory.  So also free the returned buffer if it returns 0.

These issues were found, analysed and reported to the OpenVPN team by Guido
Vranken.

CVE: 2017-7521
Signed-off-by: Steffan Karger <steffan.karger@fox-it.com>
Acked-by: Gert Doering <gert@greenie.muc.de>
Acked-by: David Sommerseth <davids@openvpn.net>
Acked-by: Guido Vranken <guidovranken@gmail.com>
Message-Id: <1497864520-12219-4-git-send-email-steffan.karger@fox-it.com>
URL: https://www.mail-archive.com/search?l=mid&q=1497864520-12219-4-git-send-email-steffan.karger@fox-it.com
Signed-off-by: Gert Doering <gert@greenie.muc.de>
(cherry picked from commit 2d032c7fcdfd692c851ea2fa858b4c2d9ea7d52d)
---
 src/openvpn/ssl_verify_openssl.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/openvpn/ssl_verify_openssl.c b/src/openvpn/ssl_verify_openssl.c
index d64f83c91..11eb7be51 100644
--- a/src/openvpn/ssl_verify_openssl.c
+++ b/src/openvpn/ssl_verify_openssl.c
@@ -139,7 +139,7 @@ bool extract_x509_extension(X509 *cert, char *fieldname, char *out, int size)
                 break;
             }
           }
-        sk_GENERAL_NAME_free (extensions);
+        GENERAL_NAMES_free(extensions);
     }
   return retval;
 }
@@ -186,8 +186,7 @@ extract_x509_field_ssl (X509_NAME *x509, const char *field_name, char *out,
   asn1 = X509_NAME_ENTRY_get_data(x509ne);
   if (!asn1)
     return FAILURE;
-  tmp = ASN1_STRING_to_UTF8(&buf, asn1);
-  if (tmp <= 0)
+  if (ASN1_STRING_to_UTF8(&buf, asn1) < 0)
     return FAILURE;
 
   strncpynt(out, (char *)buf, size);
@@ -359,7 +358,7 @@ x509_setenv_track (const struct x509_track *xt, struct env_set *es, const int de
 		  ASN1_STRING *val = X509_NAME_ENTRY_get_data (ent);
 		  unsigned char *buf;
 		  buf = (unsigned char *)1; /* bug in OpenSSL 0.9.6b ASN1_STRING_to_UTF8 requires this workaround */
-		  if (ASN1_STRING_to_UTF8 (&buf, val) > 0)
+		  if (ASN1_STRING_to_UTF8 (&buf, val) >= 0)
 		    {
 		      do_setenv_x509(es, xt->name, (char *)buf, depth);
 		      OPENSSL_free (buf);
@@ -435,7 +434,7 @@ x509_setenv (struct env_set *es, int cert_depth, openvpn_x509_cert_t *peer_cert)
       if (!objbuf)
 	continue;
       buf = (unsigned char *)1; /* bug in OpenSSL 0.9.6b ASN1_STRING_to_UTF8 requires this workaround */
-      if (ASN1_STRING_to_UTF8 (&buf, val) <= 0)
+      if (ASN1_STRING_to_UTF8 (&buf, val) < 0)
 	continue;
       name_expand_size = 64 + strlen (objbuf);
       name_expand = (char *) malloc (name_expand_size);
